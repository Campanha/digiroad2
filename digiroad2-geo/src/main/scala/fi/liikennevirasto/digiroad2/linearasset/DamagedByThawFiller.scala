package fi.liikennevirasto.digiroad2.linearasset

import fi.liikennevirasto.digiroad2
import fi.liikennevirasto.digiroad2.asset._
import fi.liikennevirasto.digiroad2.linearasset.LinearAssetFiller.{ChangeSet, ValueAdjustment}
import org.joda.time.DateTime

class DamagedByThawFiller extends AssetFiller {
  val ActivePeriod = "spring_thaw_period"
  val Repetition = "annual_repetition"
  private val today = DateTime.now()

  override protected def updateValues(roadLink: RoadLink, assets: Seq[PersistedLinearAsset], changeSet: ChangeSet): (Seq[PersistedLinearAsset], ChangeSet) = {

    def getProperties(publicId: String, propertyData: Seq[DynamicProperty]): Seq[DynamicPropertyValue] = {
      propertyData.find(p => p.publicId == publicId) match {
        case Some(props) => props.values
        case _ => Seq()
      }
    }

    def toCurrentYear(period: DatePeriodValue): DatePeriodValue = {
      val endDate = period.endDate.get
      val difference = today.getYear - endDate.getYear
      if(difference == 0)
        DatePeriodValue(Some(period.startDate.get.plusYears(1)), Some(endDate.plusYears(1)))
      else
        DatePeriodValue(Some(period.startDate.get.plusYears(difference)), Some(endDate.plusYears(difference)))
    }

    def needsUpdate(value: DynamicPropertyValue): Boolean = {
      val period = value.value.asInstanceOf[DatePeriodValue]
      val endDate = period.endDate.get
      val thisYear = today.getYear
      val endDateYear = endDate.getYear

      thisYear - endDateYear >= 0 && endDate.isBefore(today)
    }

    def isRepeated(checkbox: Seq[DynamicPropertyValue]): Boolean = {
      checkbox.exists(x => x.value.asInstanceOf[String].equals("1"))
    }

    def needUpdates(properties: Seq[DynamicProperty]): Boolean = {
      isRepeated(getProperties(Repetition, properties)) &&
        getProperties(ActivePeriod, properties).exists { period =>
          needsUpdate(period)
        }
    }

    val (toUpdate, noneNeeded) = assets.partition( asset =>
      asset.value.map(_.asInstanceOf[DynamicValue].value.properties).exists {
        propertyData => needUpdates(propertyData)
      }
    )

    val adjustedAssets = toUpdate.map { asset =>
      asset.copy(value = Some(DynamicValue(DynamicAssetValue(asset.value.get.asInstanceOf[DynamicValue].value.properties.map { prop =>
          if (prop.publicId == ActivePeriod) {
            prop.copy(values = prop.values.map { period =>
              if(needsUpdate(period))
                DynamicPropertyValue(DatePeriodValue.toMap(period.value.asInstanceOf[DatePeriodValue]))
              else
                period
            })
          } else prop
      }))), modifiedBy = Some(AutoGeneratedValues.annualUpdate))
    }

    (adjustedAssets ++ noneNeeded, changeSet.copy(valueAdjustments = changeSet.valueAdjustments ++ adjustedAssets.map {asset => ValueAdjustment(asset)}))
  }
}
