package fi.liikennevirasto.digiroad2.dao

import slick.driver.JdbcDriver.backend.Database
import Database.dynamicSession
import com.github.tototoshi.slick.MySQLJodaSupport._
import fi.liikennevirasto.digiroad2.asset.AutoGeneratedValues
import fi.liikennevirasto.digiroad2.oracle.MassQuery
import fi.liikennevirasto.digiroad2.service.{LatestModificationInfo, VerificationInfo}
import org.joda.time.DateTime
import slick.jdbc.StaticQuery.interpolation

class VerificationDao {
  val TwoYears: Int = 24

  def getVerifiedAssetTypes(municipalityId: Int) : List[VerificationInfo] = {
    val verifiedAssetTypes =
      sql"""
       SELECT tableResult.id, tableResult.name_fi, tableResult.verified_by, tableResult.verified_date, tableResult.assetId, tableResult.assetName,
              tableResult.verified, tableResult.geometry_type, tableResult.counting
         FROM
         (SELECT m.id, m.name_fi, mv.verified_by, mv.verified_date, atype.id AS assetId, atype.name AS assetName,
                (CASE
                    WHEN MONTHS_BETWEEN(sysdate, mv.verified_date) < $TwoYears
                      THEN 1
                      ELSE 0
                END) AS verified,
                atype.GEOMETRY_TYPE,
                (CASE
                    WHEN atype.GEOMETRY_TYPE = 'point'
                      THEN count(a.id)
                      ELSE NULL
                END) AS counting
                FROM municipality m
                JOIN asset_type atype ON atype.verifiable = 1
                LEFT JOIN municipality_verification mv ON mv.municipality_id = m.id AND mv.asset_type_id = atype.id AND mv.valid_to IS NULL OR mv.valid_to > sysdate
                LEFT JOIN asset a ON a.ASSET_TYPE_ID = atype.ID and a.municipality_code = m.id AND a.VALID_TO IS NULL
                WHERE m.id = $municipalityId
                GROUP BY m.id, m.name_fi, mv.verified_by, mv.verified_date, atype.id, atype.name,
                      (CASE WHEN MONTHS_BETWEEN(sysdate, mv.verified_date) < $TwoYears THEN 1 ELSE 0 END),
                      atype.GEOMETRY_TYPE ) tableResult""".as[(Int, String, Option[String], Option[DateTime], Int, String, Boolean, String, Option[Int])].list
    verifiedAssetTypes.map { case ( municipalityCode, municipalityName, verifiedBy, verifiedDate, assetTypeCode, assetTypeName, verified, geometryType, counter) =>
      VerificationInfo(municipalityCode, municipalityName, assetTypeCode, assetTypeName, verifiedBy, verifiedDate, verified, geometryType, counter)
    }
  }

  def getVerifiedInfoTypes(municipalityId: Int) : List[VerificationInfo] = {
    val verifiedAssetTypes =
      sql"""
          SELECT m.id, m.name_fi, mv.verified_by, mv.verified_date, atype.id AS typeId, atype.name AS assetName,
          (CASE WHEN MONTHS_BETWEEN(sysdate, mv.verified_date) < $TwoYears THEN 1 ELSE 0 END) AS verified, atype.geometry_type
           FROM municipality m
           JOIN asset_type atype ON atype.verifiable = 1
           LEFT JOIN municipality_verification mv ON mv.municipality_id = m.id AND mv.asset_type_id = atype.id AND mv.valid_to IS NULL OR mv.valid_to > sysdate
           WHERE m.id = $municipalityId""".as[(Int, String, Option[String], Option[DateTime], Int, String, Boolean, String)].list
    verifiedAssetTypes.map { case ( municipalityCode, municipalityName, verifiedBy, verifiedDate, assetTypeCode, assetTypeName, verified, geometryType) =>
      VerificationInfo(municipalityCode, municipalityName, assetTypeCode, assetTypeName, verifiedBy, verifiedDate, verified, geometryType)
    }
  }

  def getNumberOfPointAssets(municipalityId: Int) : Seq[(Int, Int)] = {
      sql"""
           Select a.asset_type_id , count(a.id)
                from asset_type atype
                JOIN asset a ON a.ASSET_TYPE_ID = atype.ID and (a.valid_to IS NULL OR a.valid_to > SYSDATE )
                WHERE a.municipality_code = $municipalityId
                and atype.verifiable = 1
                and atype.GEOMETRY_TYPE = 'point'
                GROUP BY a.asset_type_id """.as[(Int, Int)].list
  }

  def getLastModificationPointAssets(municipalityId: Int) : Seq[LatestModificationInfo] = {
    val lastModification =
      sql"""
        select typeId, modified_date, modified_by
        from  (
          select atype.id AS typeId, atype.GEOMETRY_TYPE as geomType, a.modified_date, a.modified_by,
          ROW_NUMBER () OVER (PARTITION BY a.asset_type_id, a.modified_by ORDER BY a.modified_date desc nulls last) AS rownumber
          from asset_type atype
          JOIN asset a ON a.ASSET_TYPE_ID = atype.ID  AND a.VALID_TO IS NULL
          WHERE atype.verifiable = 1
          and a.municipality_code = $municipalityId
          and atype.GEOMETRY_TYPE = 'point'
          and a.modified_by not in ('#${AutoGeneratedValues.allAutoGeneratedValues.mkString("','")}')
        ) tb
        where tb.rownumber = 1""".as[(Int, Option[DateTime], Option[String])].list
    lastModification.map { case ( typeId, modifiedDate, modifiedBy) =>
      LatestModificationInfo(typeId, modifiedBy, modifiedDate)
    }
  }

  def getLastModificationLinearAssets(ids: Set[Long]) : Seq[LatestModificationInfo] = {
    val lastModification = MassQuery.withIds(ids) { idTableName =>
      sql"""
      select typeId, modified_date, modified_by
      from (
        SELECT a.asset_type_id AS typeId, a.modified_date, a.modified_by,
        ROW_NUMBER () OVER (PARTITION BY a.asset_type_id, a.modified_by ORDER BY a.modified_date desc nulls last) AS rownumber
        from asset a
        join asset_link al on a.id = al.asset_id
        join lrm_position lrm on lrm.id = al.position_id
        where lrm.link_id in (select id from #$idTableName)
        and a.ASSET_TYPE_ID  in (40 , 50, 60, 190, 30, 70, 80, 90, 20, 100, 110, 120, 130, 140, 160, 210, 380)
        AND a.VALID_TO IS NULL
        and a.modified_by not in ('#${AutoGeneratedValues.allAutoGeneratedValues.mkString("','")}')
      ) tb
      where tb.rownumber = 1 """.as[(Int, Option[DateTime], Option[String])].list
    }
    lastModification.map { case ( typeId, modifiedDate, modifiedBy) =>
      LatestModificationInfo(typeId, modifiedBy, modifiedDate)
    }
  }

  def getAssetVerification(municipalityCode: Int, assetTypeCode: Int): Seq[VerificationInfo] = {
    val verifiedAssetType =
      sql"""
       SELECT tableResult.id, tableResult.name_fi, tableResult.verified_by, tableResult.verified_date, tableResult.assetId, tableResult.assetName,
              tableResult.verified, tableResult.geometry_type, tableResult.counting
         FROM
         (SELECT m.id, m.name_fi, mv.verified_by, mv.verified_date, atype.id AS assetId, atype.name AS assetName,
                (CASE
                    WHEN MONTHS_BETWEEN(sysdate, mv.verified_date) < $TwoYears
                      THEN 1
                      ELSE 0
                END) AS verified,
                atype.GEOMETRY_TYPE,
                (CASE
                    WHEN atype.GEOMETRY_TYPE = 'point'
                      THEN count(*)
                      ELSE NULL
                END) AS counting
                FROM municipality m
                JOIN asset_type atype ON atype.id = $assetTypeCode
                LEFT JOIN municipality_verification mv ON mv.municipality_id = m.id and (mv.valid_to is null or mv.valid_to > sysdate) AND mv.asset_type_id = atype.id
                LEFT JOIN asset a ON a.ASSET_TYPE_ID = atype.ID
                WHERE  m.id = $municipalityCode
                GROUP BY m.id, m.name_fi, mv.verified_by, mv.verified_date, atype.id, atype.name,
                      (CASE WHEN MONTHS_BETWEEN(sysdate, mv.verified_date) < $TwoYears THEN 1 ELSE 0 END),
                      (CASE WHEN MONTHS_BETWEEN(sysdate, mv.verified_date) < $TwoYears THEN 1 ELSE 0 END),
                      atype.GEOMETRY_TYPE ) tableResult""".as[(Int, String, Option[String], Option[DateTime], Int, String, Boolean, String, Option[Int])].list

    verifiedAssetType.map { case (municipality, municipalityName, verifiedBy, verifiedDate, assetType, assetTypeName, verified, geometryType, counter) =>
      VerificationInfo(municipality, municipalityName, assetType, assetTypeName, verifiedBy, verifiedDate, verified, geometryType, counter)
    }
  }

  def getCriticalAssetVerification(municipalityId: Int, assetTypeCodes: Seq[Int]) = {
    val criticalAssetTypes =
      sql"""
          SELECT m.id, m.name_fi, mv.verified_by, mv.verified_date, atype.id AS assetId, atype.name AS assetName, atype.geometry_type
          FROM municipality m
          JOIN asset_type atype ON atype.verifiable = 1 AND atype.id IN  (#${assetTypeCodes.mkString(",")})
          LEFT JOIN municipality_verification mv ON mv.municipality_id = m.id AND mv.asset_type_id = atype.id AND mv.valid_to IS NULL OR mv.valid_to > sysdate
          WHERE m.id = $municipalityId""".as[(Int, String, Option[String], Option[DateTime], Int, String, String)].list
    criticalAssetTypes.map { case ( municipalityCode, municipalityName, verifiedBy, verifiedDate, assetTypeCode, assetTypeName, geometryType) =>
      VerificationInfo(municipalityCode, municipalityName, assetTypeCode, assetTypeName, verifiedBy, verifiedDate, geometryType = geometryType )
    }
  }

  def insertAssetTypeVerification(municipalityId: Int, assetTypeId: Int, username: String): Long = {
    val id = sql"""select primary_key_seq.nextval from dual""".as[Long].first
    sqlu"""insert into municipality_verification (id, municipality_id, asset_type_id, verified_date, verified_by)
           values ($id, $municipalityId, $assetTypeId, sysdate, $username)
      """.execute
    id
  }

  def expireAssetTypeVerification(municipalityCode: Int, assetTypeCode: Int, userName: String) = {
    sqlu"""update municipality_verification mv
           set valid_to = sysdate, modified_by = $userName
           where mv.municipality_id = $municipalityCode
           and mv.asset_type_id = $assetTypeCode
           and valid_to is null
      """.execute
    assetTypeCode
  }

  def getVerifiableAssetTypes: Seq[Int] = {
    sql"""select asst.id
           from asset_type asst
           where asst.verifiable = 1
      """.as[(Int)].list
  }

  //TODO this query seems to be best perfomance vs the current one, please test it (3.75 old(1 month)-> 2.20 for 5 months)
//  def getModifiedAssetTypes(linkIds : Set[Long]) : List[LatestModificationInfo] = {
//    val modifiedAssetTypes = MassQuery.withIds(linkIds) { idTableName =>
//      sql"""
//           select asset_type_id, modified_by, modified_date
//           from (
//              select a.asset_type_id, a.modified_by, a.modified_date,
//              ROW_NUMBER () OVER (PARTITION BY a.asset_type_id, a.modified_by ORDER BY a.modified_date desc nulls last) AS rownumber
//              from asset a
//              join asset_link al on a.id = al.asset_id
//              join lrm_position lrm on lrm.id = al.position_id
//              where a.modified_date >= add_months(sysdate, - 5)
//              and a.valid_to is null
//              and a.modified_by not in ('#${AutoGeneratedValues.allAutoGeneratedValues.mkString("','")}')
//              and lrm.link_id in (select id from #$idTableName)
//              )
//              where rownumber <= 4""".as[(Int, Option[String], Option[DateTime])].list
//      }
//    modifiedAssetTypes.map { case (assetTypeCode, modifiedBy, modifiedDate) =>
//      LatestModificationInfo(assetTypeCode,  modifiedBy, modifiedDate)
//    }
//  }

  def getModifiedAssetTypes(linkIds : Set[Long]) : List[LatestModificationInfo] = {
    val modifiedAssetTypes = MassQuery.withIds(linkIds) { idTableName =>
      sql"""
           select assetTypeId, modifiedBy, modifiedDate
           from (
              select  a.asset_type_id as assetTypeId, a.modified_by as modifiedBy, max(TO_DATE(TO_CHAR(a.modified_date, 'YYYY-MM-DD'), 'YYYY-MM-DD hh24:mi:ss')) as modifiedDate
              from asset a
              join asset_link al on a.id = al.asset_id
              join lrm_position lrm on lrm.id = al.position_id
              where a.modified_date is not null
              and a.modified_date >= add_months(sysdate, -1)
              and a.valid_to is null
              and a.modified_by not in ('#${AutoGeneratedValues.allAutoGeneratedValues.mkString("','")}')
              and lrm.link_id in (select id from #$idTableName)
              group by a.asset_type_id, a.modified_by
              order by max(a.modified_date) desc, a.asset_type_id, a.modified_by
              ) where rownum <= 4""".as[(Int, Option[String], Option[DateTime])].list
      }
    modifiedAssetTypes.map { case (assetTypeCode, modifiedBy, modifiedDate) =>
      LatestModificationInfo(assetTypeCode,  modifiedBy, modifiedDate)
    }
  }
}
